import numpy as np
#wybrac najlepsza globalnie
#wybrac najlepsza sciezke dla Particle
#porwnac aktulną losową z tymi dwoma
def findBest(paths, nodes, edges):
    pass
def generateParticles():
    particle = ()

def countCost(path):

    length = 0
    partialLength = 0

    for idx in range(len(path)-1):
        
  for (auto i = 1; i < ; i++)
  {
    currentX = this->nodes.at(i)->getPositionX();
    currentY = this->nodes.at(i)->getPositionY();

    partialLength = sqrt( pow( currentX - previousX, 2 ) + pow( currentY - previousY, 2 ) );
    length += partialLength;

    if (i != (this->nodes.size() - 1))
    {
      previousX = currentX;
      previousY = currentY;
    }
  }

  return length;
}

